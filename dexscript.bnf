{
  parserClass='com.dexscript.parser.DexParser'
  classHeader='copyrightHeader.java'

  implements='com.dexscript.psi.DexCompositeElement'
  extends='com.dexscript.psi.impl.DexCompositeElementImpl'

  elementTypeHolderClass='com.dexscript.psi.DexTypes'
  elementTypeClass='com.dexscript.psi.DexCompositeElementType'
  tokenTypeClass='com.dexscript.psi.DexTokenType'

  psiClassPrefix='Dex'
  psiImplClassSuffix='Impl'
  psiPackage='com.dexscript.psi'
  psiImplPackage='com.dexscript.psi.impl'
  psiImplUtilClass="com.dexscript.psi.impl.DexPsiImplUtil"
  parserUtilClass="com.dexscript.parser.DexParserUtil"

  tokens=[
    LBRACE               =  '{'
    RBRACE               =  '}'
    LBRACK               =  '['
    RBRACK               =  ']'
    LPAREN               =  '('
    RPAREN               =  ')'
    COLON                =  ':'
    SEMICOLON            =  ';'
    COMMA                =  ','
    EQ                   =  '=='
    ASSIGN               =  '='
    NOT_EQ               =  '!='
    NOT                  =  '!'
    PLUS_PLUS            =  '++'
    PLUS_ASSIGN          =  '+='
    PLUS                 =  '+'
    MINUS_MINUS          =  '--'
    MINUS_ASSIGN         =  '-='
    MINUS                =  '-'
    COND_OR              =  '||'
    BIT_OR_ASSIGN        =  '|='
    BIT_CLEAR_ASSIGN     =  '&^='
    BIT_CLEAR            =  '&^'
    COND_AND             =  '&&'
    BIT_AND_ASSIGN       =  '&='
    BIT_AND              =  '&'
    BIT_OR               =  '|'
    SHIFT_LEFT_ASSIGN    =  '<<='
    SHIFT_LEFT           =  '<<'
    SEND_CHANNEL         =  '<-'
    LESS_OR_EQUAL        =  '<='
    LESS                 =  '<'
    BIT_XOR_ASSIGN       =  '^='
    BIT_XOR              =  '^'
    MUL_ASSIGN           =  '*='
    MUL                  =  '*'
    QUOTIENT_ASSIGN      =  '/='
    QUOTIENT             =  '/'
    REMAINDER_ASSIGN     =  '%='
    REMAINDER            =  '%'
    SHIFT_RIGHT_ASSIGN   =  '>>='
    SHIFT_RIGHT          =  '>>'
    GREATER_OR_EQUAL     =  '>='
    GREATER              =  '>'
    VAR_ASSIGN           =  ':='
    TRIPLE_DOT           =  '...'
    DOT                  =  '.'
    SEMICOLON_SYNTHETIC  = '<NL>'
    TYPE_                = 'type'
    raw_string           = 'raw_string'
  ]

  extends("(Or|And|Add|Conversion|Mul|Selector|Conditional)Expr")=BinaryExpr
  extends(".*(Expr|Literal|Lit|OperandName)")=Expression

  implements("(Type|Import)Spec|(Var|Const|Param|(Anonymous)?Field|Label)Definition|Receiver")="com.dexscript.psi.DexNamedElement"
  implements("FunctionLit")="com.dexscript.psi.DexSignatureOwner"
  implements("FunctionDeclaration")="com.dexscript.psi.DexNamedSignatureOwner"

  extends("(Function|Method)Declaration")="com.dexscript.psi.impl.DexNamedElementImpl<?>"
  extends("(Type|Import|Method)Spec|(Var|Const|Param|(Anonymous)?Field|Label)Definition|Receiver")="com.dexscript.psi.impl.DexNamedElementImpl<?>"
  extends("PackageClause|Parameters|Signature|ParameterDeclaration|Result|Type|(Const|Var|Import)Spec")="com.dexscript.psi.impl.DexStubbedElementImpl<?>"

  pin(".*Statement")=1
  extends(".*Statement")=Statement
  extends(".*Type|TypeList")=Type

  pin('.*List(?:_\d.*)?')=1

  generateTokenAccessors=true
}

File ::= PackageClause semi ImportList TopLevelDeclaration* {pin(".*")=1}

PackageClause ::= package identifier {pin=1 methods=[getName] stubClass="com.dexscript.stubs.DexPackageClauseStub"}

private semi ::= '<NL>' | ';' | <<eof>>

ImportList ::= (ImportDeclaration semi)+|<<emptyImportList>> {
  methods=[addImport]
}

ImportDeclaration ::= import ( ImportSpec | '(' ImportSpecs? ')' ) {
  pin(".*")=1
  methods=[addImportSpec]
}

ImportSpec ::= [ '.' | identifier ] ImportString {
  stubClass="com.dexscript.stubs.DexImportSpecStub"
  methods=[getAlias getLocalPackageName shouldGoDeeper isForSideEffects isDot getPath getName isCImport]
}

private ImportSpecs ::= ImportSpec (semi ImportSpec)* semi? {pin=1}

ImportString ::= StringLiteral {methods=[getReferences resolve getPath getPathTextRange]}

StringLiteral ::= string | raw_string {
  implements = "com.intellij.psi.PsiLanguageInjectionHost"
  methods = [isValidHost updateText createLiteralTextEscaper getDecodedText]
}

private TopLevelDeclaration ::= !<<eof>> TopDeclaration semi {pin=1 recoverWhile=TopLevelDeclarationRecover}

private TopLevelDeclarationRecover ::= !(';' | function)

private TopDeclaration ::=
  FunctionDeclaration

FunctionDeclaration ::= function identifier Signature BlockWithConsume? {
  pin=2
  stubClass="com.dexscript.stubs.DexFunctionDeclarationStub"
}

FunctionType ::= func Signature {pin=1 implements="com.dexscript.psi.DexSignatureOwner"}
Signature ::= Parameters Result? {
  pin=1
  stubClass="com.dexscript.stubs.DexSignatureStub"
}
Result ::= '(' TypeListNoPin ')' | Type | Parameters { // todo: reorder and pin (
  stubClass="com.dexscript.stubs.DexResultStub"
  methods=[isVoid]
}
Parameters ::= '(' [ (ParameterList ','?| TypeListNoPin) ] ')' {
  pin=1
  stubClass="com.dexscript.stubs.DexParametersStub"
}
private ParameterList ::= ParameterDeclaration (',' (ParameterDeclaration | &')'))* {pin(".*")=1}
ParameterDeclaration ::= ParamDefinitionListNoPin? '...'? Type | Type { // todo: use left rule
  stubClass="com.dexscript.stubs.DexParamDeclarationStub"
  methods = [isVariadic]
}
private ParamDefinitionListNoPin ::= ParamDefinition &(!('.' | ')')) (',' ParamDefinition)* // todo
ParamDefinition ::= identifier {
  stubClass="com.dexscript.stubs.DexParamDefinitionStub"
  methods = [isVariadic]
}

TypeList ::= Type ( ',' Type )* ','?
TypeListNoPin ::= Type ( ',' Type )* ','? {elementType=TypeList}

Type ::= TypeName | TypeLit | ParType {stubClass="com.dexscript.stubs.DexTypeStub" methods=[getUnderlyingType shouldGoDeeper]}
ParType ::= '(' Type ')' {methods=[getActualType]}
private TypeName ::= TypeReferenceExpression QualifiedTypeReferenceExpression?
TypeReferenceExpression ::= identifier { methods=[getReference getQualifier resolve resolveType] }
left QualifiedTypeReferenceExpression ::= '.' identifier {elementType=TypeReferenceExpression}

private TypeLit ::=
  FunctionType

BlockWithConsume ::= <<consumeBlock>> | BlockInner {elementType=Block}
Block ::= BlockInner {methods=[processDeclarations]}
private BlockInner ::= '{' ('}' | (<<withOff Statements "BLOCK?" "PAR">> | (!() Statements)) '}') {pin(".*")=1}
private Statements ::= StatementWithSemi*

private StatementWithSemi ::= Statement (semi|&'}') { pin=1 recoverWhile=StatementRecover }
Statement ::=
    ReturnStatement
  | Block
private StatementRecover ::= !('!' | '&' | '(' | '*' | '+' | '-' | ';' | '<-' | '^' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var)

ReturnStatement ::= return ExpressionList?

LeftHandExprList ::= ExpressionList
private ExpressionArgList ::= ExpressionOrTypeWithRecover2 (',' (ExpressionOrTypeWithRecover2 | &')'))* {pin(".*")=1}
private ExpressionOrTypeWithRecover2 ::= <<withOn "PAR" ExpressionOrTypeWithRecover>> | (!() ExpressionOrLiteralTypeExpr) {recoverWhile=ExpressionListRecover}
private ExpressionOrTypeWithRecover ::= ExpressionOrLiteralTypeExpr {recoverWhile=ExpressionListRecover}
private ExpressionOrLiteralTypeExpr ::= Expression | LiteralTypeExpr

private ExpressionList ::= ExpressionWithRecover (',' (ExpressionWithRecover | &')'))* {pin(".*")=1}
private ExpressionWithRecover ::= Expression {recoverWhile=ExpressionListRecover}
private ExpressionListRecover ::= !('!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '...' | '/' | '/=' | ':' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '<NL>' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | ']' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | chan | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var)

fake BinaryExpr ::= Expression+ {
  methods=[left="Expression[0]" right="Expression[1]" getOperator]
}

OrExpr ::= Expression '||' Expression
AndExpr ::= Expression '&&' Expression
UnaryExpr ::=  UnaryOp Expression {methods=[getOperator]}
ConditionalExpr ::= Expression RelOp Expression
AddExpr ::= Expression AddOp Expression
MulExpr ::= Expression MulOp Expression
ParenthesesExpr ::= '(' <<enterMode "PAR">> Expression <<exitModeSafe "PAR">>')' {pin=1}

Expression ::=
    OrExpr
  | AndExpr
  | ConditionalExpr
  | AddExpr
  | MulExpr
  | UnaryExpr
  | ParenthesesExpr {methods=[getDexType] implements="com.dexscript.psi.DexTypeOwner"}